// Generated by CoffeeScript 1.6.3
(function() {
  var Connection, attachNetwork, attachStorage, bootstrapSaltminions, buildNetwork, buildServers, buildStorage, rack, racksjs, recipe, runHighstate, sleep, sshCommand, steak, verifyCluster,
    _this = this;

  racksjs = require('./racks.js');

  rack = false;

  Connection = require('ssh2');

  sleep = require('sleep');

  recipe = {
    servers: {
      'gluster1': {
        name: 'gluster1',
        imageRef: "80fbcb55-b206-41f9-9bc2-2dd7aac6c061",
        flavorRef: "performance1-1",
        metadata: {
          label: 'glusterfs-node'
        }
      }
    },
    networks: {
      'gluster-private': {
        label: 'gluster-private',
        cidr: '172.16.0.0/24'
      }
    },
    storage: {
      'gluster1': {
        display_name: 'gluster1',
        size: '100'
      }
    }
  };

  steak = {
    servers: {},
    networks: {},
    storage: {}
  };

  new racksjs({
    username: process.argv[2],
    apiKey: process.argv[3],
    verbosity: 0,
    cache: false
  }, function(rs) {
    rack = rs;
    rack.datacenter = 'IAD';
    return buildServers(recipe.servers, function(servers) {
      return buildNetwork(recipe.networks, function(networks) {
        return buildStorage(recipe.storage, function(storage) {
          return attachNetwork(steak.networks, steak.servers, function(vips) {
            return attachStorage(steak.storage, steak.servers, function(devices) {
              return bootstrapSaltminions(steak.servers, function(minions) {
                return runHighstate(steak.servers, function(cluster) {
                  var details, server, _ref, _results;
                  _ref = steak.servers;
                  _results = [];
                  for (server in _ref) {
                    details = _ref[server];
                    _results.push(console.log(details.info));
                  }
                  return _results;
                });
              });
            });
          });
        });
      });
    });
  });

  buildServers = function(servers, cb) {
    var apiCalls, name, server, _results;
    apiCalls = 0;
    _results = [];
    for (name in servers) {
      server = servers[name];
      apiCalls++;
      console.log('creating server:', name);
      _results.push(rack.servers["new"](server, function(response) {
        console.log('server creation submitted for:', response.id);
        return response.systemActive(function(details) {
          console.log('server created:', details.name, 'at', details.accessIPv4);
          steak.servers[details.name] = response;
          steak.servers[details.name].info = details;
          apiCalls--;
          if (apiCalls === 0) {
            return cb();
          }
        });
      }));
    }
    return _results;
  };

  buildNetwork = function(networks, cb) {
    var name, network, _results;
    _results = [];
    for (name in networks) {
      network = networks[name];
      console.log('creating network', name, network);
      _results.push(rack.networks["new"](network, function(cloudnet) {
        console.log('network created', cloudnet.id);
        steak.networks[cloudnet.label] = cloudnet;
        return cb();
      }));
    }
    return _results;
  };

  buildStorage = function(storage, cb) {
    var apiCalls, name, volume, _results;
    apiCalls = 0;
    _results = [];
    for (name in storage) {
      volume = storage[name];
      apiCalls++;
      console.log('creating volume', name, 'size', volume.size);
      _results.push(rack.cloudBlockStorage.volumes["new"](volume, function(details) {
        console.log('created volume', details.id);
        steak.storage[details.display_name] = details;
        apiCalls--;
        if (apiCalls === 0) {
          return cb();
        }
      }));
    }
    return _results;
  };

  attachNetwork = function(networks, servers, cb) {
    var apiCalls, id, name, network, server, _results;
    _results = [];
    for (id in networks) {
      network = networks[id];
      apiCalls = 0;
      console.log('network found:', network.label);
      _results.push((function() {
        var _results1;
        _results1 = [];
        for (name in servers) {
          server = servers[name];
          apiCalls++;
          _results1.push((function() {
            var myserver, servername;
            servername = name;
            myserver = server;
            return myserver.attachNetwork({
              network_id: network.id
            }, function(vip) {
              sleep.sleep(10);
              return myserver.getVips(function(vips) {
                var address, item, _i, _len, _ref, _results2;
                _ref = vips.virtual_interfaces;
                _results2 = [];
                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                  item = _ref[_i];
                  _results2.push((function() {
                    var _j, _len1, _ref1, _results3;
                    _ref1 = item.ip_addresses;
                    _results3 = [];
                    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                      address = _ref1[_j];
                      if (address.network_label === network.label) {
                        steak.servers[servername].info.glusterVip = address.address;
                        console.log('gluster-network address', address);
                        apiCalls--;
                        if (apiCalls === 0) {
                          _results3.push(cb());
                        } else {
                          _results3.push(void 0);
                        }
                      } else {
                        _results3.push(void 0);
                      }
                    }
                    return _results3;
                  })());
                }
                return _results2;
              });
            });
          })());
        }
        return _results1;
      })());
    }
    return _results;
  };

  attachStorage = function(volumes, servers, cb) {
    var attachment, id, name, server, volume, _results;
    _results = [];
    for (id in volumes) {
      volume = volumes[id];
      console.log('found volume', id);
      _results.push((function() {
        var _results1;
        _results1 = [];
        for (name in servers) {
          server = servers[name];
          if (name === volume.display_name) {
            attachment = {
              volumeAttachment: {
                device: null,
                volumeId: volume.id
              }
            };
            console.log('attaching volume', id, 'to server', name);
            _results1.push(server.attachVolume(attachment, function(volId) {
              console.log('attachment deatils', volId.volumeAttachment.device);
              return cb();
            }));
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      })());
    }
    return _results;
  };

  bootstrapSaltminions = function(minions, cb) {
    var bootstrap, minion, name, server, _results;
    bootstrap = 'curl -L http://bootstrap.saltstack.org | sh';
    _results = [];
    for (name in minions) {
      server = minions[name];
      minion = {
        host: server.info.accessIPv4,
        port: 22,
        username: 'root',
        password: server.adminPass
      };
      console.log('target:', minion.host);
      _results.push(sshCommand(minion, bootstrap, function(reply) {
        return cb();
      }));
    }
    return _results;
  };

  runHighstate = function(minions, cb) {
    var extractHighState, getHighState, highState, minion, name, server, _results;
    getHighState = 'wget -O /root/recipes.tar -r -np https://github.com/asdqwex/salted-gluster/raw/master/recipes.tar';
    extractHighState = 'mkdir -p /srv/salt && tar -xvf /root/recipes.tar -C /srv/salt';
    highState = 'salt-call -l quiet --local state.highstate';
    minion = {};
    _results = [];
    for (name in minions) {
      server = minions[name];
      minion = {
        host: server.info.accessIPv4,
        port: 22,
        username: 'root',
        password: server.adminPass
      };
      _results.push(sshCommand(minion, getHighState, function() {
        return sshCommand(minion, extractHighState, function() {
          return sshCommand(minion, highState, function() {
            return cb();
          });
        });
      }));
    }
    return _results;
  };

  verifyCluster = function(mountpoint, cb) {};

  sshCommand = function(target, command, cb) {
    var c;
    c = new Connection();
    c.on('ready', function() {
      console.log('Connection :: ready');
      return c.exec(command, function(err, stream) {
        if (err) {
          throw err;
        }
        stream.on('data', function(data, extended) {
          var _ref;
          return console.log(((_ref = extended === 'stderr') != null ? _ref : {
            'STDERR: ': 'STDOUT: '
          }) + data);
        });
        stream.on('end', function() {
          return console.log('Stream :: EOF');
        });
        stream.on('close', function() {
          return console.log('Stream :: close');
        });
        return stream.on('exit', function(code, signal) {
          console.log('Stream :: exit :: code: ' + code + ', signal: ' + signal);
          return c.end();
        });
      });
    });
    c.on('error', function(err) {
      return console.log('Connection :: error :: ' + err);
    });
    c.on('end', function() {
      return console.log('Connection :: end');
    });
    c.on('close', function(had_error) {
      console.log('Connection :: close');
      return cb();
    });
    return c.connect(target);
  };

}).call(this);
